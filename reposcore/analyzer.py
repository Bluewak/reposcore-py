#!/usr/bin/env python3

from typing import Dict, Optional
import matplotlib.font_manager as fm
import matplotlib.pyplot as plt
import matplotlib.cm as cm

import pandas as pd
import requests
from prettytable import PrettyTable
from datetime import datetime
from zoneinfo import ZoneInfo
from .utils.retry_request import retry_request
from .utils.theme_manager import ThemeManager 

import logging
import sys
import os

from .utils.github_utils import check_github_repo_exists

logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

ERROR_MESSAGES = {
    401: "‚ùå Ïù∏Ï¶ù Ïã§Ìå®: ÏûòÎ™ªÎêú GitHub ÌÜ†ÌÅ∞ÏûÖÎãàÎã§. ÌÜ†ÌÅ∞ Í∞íÏùÑ ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.",
    403: ("‚ö†Ô∏è ÏöîÏ≤≠ Ïã§Ìå® (403): GitHub API rate limitÏóê ÎèÑÎã¨ÌñàÏäµÎãàÎã§.\n"
            "üîë ÌÜ†ÌÅ∞ ÏóÜÏù¥ Ïã§ÌñâÌïòÎ©¥ 1ÏãúÍ∞ÑÏóê ÏµúÎåÄ 60Ìöå ÏöîÏ≤≠Îßå ÌóàÏö©Îê©ÎãàÎã§.\n"
            "üí° Ìï¥Í≤∞Î≤ï: --api-key ÏòµÏÖòÏúºÎ°ú GitHub Í∞úÏù∏ Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ÏùÑ ÏÑ§Ï†ïÌï¥ Ï£ºÏÑ∏Ïöî."),
    404: "‚ö†Ô∏è ÏöîÏ≤≠ Ïã§Ìå® (404): Î¶¨Ìè¨ÏßÄÌÜ†Î¶¨Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.",
    500: "‚ö†Ô∏è ÏöîÏ≤≠ Ïã§Ìå® (500): GitHub ÎÇ¥Î∂Ä ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù!",
    503: "‚ö†Ô∏è ÏöîÏ≤≠ Ïã§Ìå® (503): ÏÑúÎπÑÏä§ Î∂àÍ∞Ä",
    422: ("‚ö†Ô∏è ÏöîÏ≤≠ Ïã§Ìå® (422): Ï≤òÎ¶¨Ìï† Ïàò ÏóÜÎäî Ïª®ÌÖêÏ∏†\n"
            "‚ö†Ô∏è Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨Ïóê Ïã§Ìå® ÌñàÍ±∞ÎÇò, ÏóîÎìú Ìè¨Ïù∏Ìä∏Í∞Ä Ïä§Ìå∏ Ï≤òÎ¶¨ÎêòÏóàÏäµÎãàÎã§.")
}

class RepoAnalyzer:
    """Class to analyze repository participation for scoring"""
    # Ï†êÏàò Í∞ÄÏ§ëÏπò
    SCORE_WEIGHTS = {
        'feat_bug_pr': 3,
        'doc_pr': 2,
        'typo_pr': 1,
        'feat_bug_is': 2,
        'doc_is': 1
    }
    
    # Ï∞®Ìä∏ ÏÑ§Ï†ï
    CHART_CONFIG = {
        'height_per_participant': 0.4,  # Ï∞∏Ïó¨ÏûêÎãπ Ï∞®Ìä∏ ÎÜíÏù¥
        'min_height': 3.0,             # ÏµúÏÜå Ï∞®Ìä∏ ÎÜíÏù¥
        'bar_height': 0.5,             # ÎßâÎåÄ ÎÜíÏù¥
        'figure_width': 10,            # Ï∞®Ìä∏ ÎÑàÎπÑ
        'label_offset': 0.5,           # Î†àÏù¥Î∏î Ïò§ÌîÑÏÖã
        'font_size': 9                 # Ìè∞Ìä∏ ÌÅ¨Í∏∞
    }
    
    # Îì±Í∏â Í∏∞Ï§Ä
    GRADE_THRESHOLDS = {
        90: 'A',
        80: 'B',
        70: 'C',
        60: 'D',
        50: 'E',
        0: 'F'
    }

    # ÏÇ¨Ïö©Ïûê Ï†úÏô∏ Î™©Î°ù
    EXCLUDED_USERS = {"kyahnu", "kyagrd"}

    def __init__(self, repo_path: str, token: Optional[str] = None, theme: str = 'default'):
        """
        Î∂ÑÏÑùÍ∏∞ ÌÅ¥ÎûòÏä§Ïùò Ïù∏Ïä§ÌÑ¥Ïä§Î•º Ï¥àÍ∏∞ÌôîÌï©ÎãàÎã§.

        Args:
            repo_path (str):  GitHub Ï†ÄÏû•ÏÜå Í≤ΩÎ°ú (Ïòà: 'owner/repo').
            token (Optional[str], optional): GitHub Personal Access Token(PAT). Í∏∞Î≥∏Í∞íÏùÄ NoneÏûÖÎãàÎã§.
            theme (str, optional): ÏÇ¨Ïö©Ìï† ÌÖåÎßà Ïù¥Î¶Ñ. Í∏∞Î≥∏Í∞íÏùÄ 'default'ÏûÖÎãàÎã§.
        """        
        if not check_github_repo_exists(repo_path, bypass=True): #ÌÖåÏä§Ìä∏ Ï§ëÏù¥ÎØÄÎ°ú Î¨¥Ï°∞Í±¥ True Î∞òÌôò
            logging.error(f"ÏûÖÎ†•Ìïú Ï†ÄÏû•ÏÜå '{repo_path}'Í∞Ä GitHubÏóê Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.")
            sys.exit(1)

        self.repo_path = repo_path
        self.participants: Dict[str, Dict[str, int]] = {}
        self.score = self.SCORE_WEIGHTS.copy()

        self.theme_manager = ThemeManager()  # ÌÖåÎßà Îß§ÎãàÏ†Ä Ï¥àÍ∏∞Ìôî
        self.set_theme(theme)                # ÌÖåÎßà ÏÑ§Ï†ï

        self._data_collected = True

        self.SESSION = requests.Session()
        if token:
            self.SESSION.headers.update({'Authorization': f'Bearer {token}'})

    def set_theme(self, theme_name: str) -> None:
        """
        ÌòÑÏû¨ ÏÇ¨Ïö©Ìï† ÌÖåÎßàÎ•º ÏÑ§Ï†ïÌï©ÎãàÎã§.

        Args:
            theme_name (str): ÏÇ¨Ïö©Ìï† ÌÖåÎßà Ïù¥Î¶Ñ (Ïòà: 'default', 'dark').

        Raises:
            ValueError: ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÌÖåÎßà Ïù¥Î¶ÑÏùº Í≤ΩÏö∞ ÏòàÏô∏Î•º Î∞úÏÉùÏãúÌÇµÎãàÎã§.
        """
        if theme_name in self.theme_manager.themes:
            self.theme_manager.current_theme = theme_name
        else:
            raise ValueError(f"ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÌÖåÎßàÏûÖÎãàÎã§: {theme_name}")

    def _handle_api_error(self, status_code: int) -> bool:
         """
        GitHub API ÏöîÏ≤≠ Ïã§Ìå® Ïãú ÏÉÅÌÉú ÏΩîÎìúÏóê Îî∞Îùº Ïò§Î•òÎ•º Ï≤òÎ¶¨Ìï©ÎãàÎã§.

        Args:
            status_code (int): API ÏùëÎãµÏùò HTTP ÏÉÅÌÉú ÏΩîÎìú.

        Returns:
            bool: Ïò§Î•òÍ∞Ä Ï≤òÎ¶¨ÎêòÏóàÏúºÎ©¥ True, Í∑∏Î†áÏßÄ ÏïäÏúºÎ©¥ FalseÎ•º Î∞òÌôòÌï©ÎãàÎã§.
        """
        if status_code in ERROR_MESSAGES:
            logging.error(ERROR_MESSAGES[status_code])
            self._data_collected = False
            return True
        elif status_code != 200:
            logging.warning(f"‚ö†Ô∏è GitHub API ÏöîÏ≤≠ Ïã§Ìå®: {status_code}")
            self._data_collected = False
            return True
        return False

    def collect_PRs_and_issues(self) -> None:
        """
        ÌïòÎÇòÏùò API Ìò∏Ï∂úÎ°ú GitHub Ïù¥Ïäà Î™©Î°ùÏùÑ Í∞ÄÏ†∏Ïò§Í≥†,
        pull_request ÌïÑÎìúÍ∞Ä ÏûàÏúºÎ©¥ PRÎ°ú, ÏóÜÏúºÎ©¥ issueÎ°ú Í∞ÑÏ£º.
        PRÏùò Í≤ΩÏö∞, Ïã§Ï†úÎ°ú Î≥ëÌï©Îêú Í≤ΩÏö∞Îßå Ï†êÏàòÏóê Î∞òÏòÅ.
        Ïù¥ÏäàÎäî open / reopened / completed ÏÉÅÌÉúÎßå Ï†êÏàòÏóê Î∞òÏòÅÌï©ÎãàÎã§.
        """
        page = 1
        per_page = 100

        while True:
            url = f"https://api.github.com/repos/{self.repo_path}/issues"

            response = retry_request(self.SESSION,
                                    url,
                                    max_retries=3,
                                    params={
                                        'state': 'all',
                                        'per_page': per_page,
                                        'page': page
                                    })
           
             # üîΩ ÏóêÎü¨ Ï≤òÎ¶¨ Î∂ÄÎ∂Ñ 25Ï§Ñ ‚Üí 3Ï§ÑÎ°ú Î¶¨Ìå©ÌÜ†ÎßÅ
            if self._handle_api_error(response.status_code):
                return

            items = response.json()
            if not items:
                break

            for item in items:
                author = item.get('user', {}).get('login', 'Unknown')
                if author not in self.participants:
                    self.participants[author] = {
                        'p_enhancement': 0,
                        'p_bug': 0,
                        'p_documentation': 0,
                        'p_typo' : 0,
                        'i_enhancement': 0,
                        'i_bug': 0,
                        'i_documentation': 0,
                    }

                labels = item.get('labels', [])
                label_names = [label.get('name', '') for label in labels if label.get('name')]

                state_reason = item.get('state_reason')

                # PR Ï≤òÎ¶¨ (Î≥ëÌï©Îêú PRÎßå)
                if 'pull_request' in item:
                    merged_at = item.get('pull_request', {}).get('merged_at')
                    if merged_at:
                        for label in label_names:
                            key = f'p_{label}'
                            if key in self.participants[author]:
                                self.participants[author][key] += 1

                # Ïù¥Ïäà Ï≤òÎ¶¨ (open / reopened / completed Îßå Ìè¨Ìï®, not planned Ï†úÏô∏)
                else:
                    if state_reason in ('completed', 'reopened', None):
                        for label in label_names:
                            key = f'i_{label}'
                            if key in self.participants[author]:
                                self.participants[author][key] += 1

            # Îã§Ïùå ÌéòÏù¥ÏßÄ Í≤ÄÏÇ¨
            link_header = response.headers.get('link', '')
            if 'rel="next"' in link_header:
                page += 1
            else:
                break

        if not self.participants:
            logging.warning("‚ö†Ô∏è ÏàòÏßëÎêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§. (Ï∞∏Ïó¨Ïûê ÏóÜÏùå)")
            logging.info("üìÑ Ï∞∏Ïó¨ÏûêÎäî ÏóÜÏßÄÎßå, Í≤∞Í≥º ÌååÏùºÏùÄ ÏÉùÏÑ±Îê©ÎãàÎã§.")
        else:
            self.participants = {
                user: info for user, info in self.participants.items()
                if user not in self.EXCLUDED_USERS
            }
            logging.info("\nÏ∞∏Ïó¨ÏûêÎ≥Ñ ÌôúÎèô ÎÇ¥Ïó≠ (participants ÎîïÏÖîÎÑàÎ¶¨):")
            for user, info in self.participants.items():
                logging.info(f"{user}: {info}")

    def _extract_pr_counts(self, activities: Dict) -> tuple[int, int, int, int, int]:
        """PR Í¥ÄÎ†® Ïπ¥Ïö¥Ìä∏ Ï∂îÏ∂ú"""
        p_f = activities.get('p_enhancement', 0)
        p_b = activities.get('p_bug', 0)
        p_d = activities.get('p_documentation', 0)
        p_t = activities.get('p_typo', 0)
        p_fb = p_f + p_b
        return p_f, p_b, p_d, p_t, p_fb

    def _extract_issue_counts(self, activities: Dict) -> tuple[int, int, int, int]:
        """Ïù¥Ïäà Í¥ÄÎ†® Ïπ¥Ïö¥Ìä∏ Ï∂îÏ∂ú"""
        i_f = activities.get('i_enhancement', 0)
        i_b = activities.get('i_bug', 0)
        i_d = activities.get('i_documentation', 0)
        i_fb = i_f + i_b
        return i_f, i_b, i_d, i_fb

    def _calculate_valid_counts(self, p_fb: int, p_d: int, i_fb: int, i_d: int) -> tuple[int, int]:
        """Ïú†Ìö® Ïπ¥Ïö¥Ìä∏ Í≥ÑÏÇ∞"""
        p_valid = p_fb + min(p_d, 3 * max(p_fb, 1))
        i_valid = min(i_fb + i_d, 4 * p_valid)
        return p_valid, i_valid

    def _calculate_adjusted_counts(self, p_fb: int, p_valid: int, i_fb: int, i_valid: int) -> tuple[int, int, int, int]:
        """Ï°∞Ï†ïÎêú Ïπ¥Ïö¥Ìä∏ Í≥ÑÏÇ∞"""
        p_fb_at = min(p_fb, p_valid)
        p_d_at = p_valid - p_fb_at
        i_fb_at = min(i_fb, i_valid)
        i_d_at = i_valid - i_fb_at
        return p_fb_at, p_d_at, i_fb_at, i_d_at

    def _calculate_total_score(self, p_fb_at: int, p_d_at: int, p_t: int, i_fb_at: int, i_d_at: int) -> int:
        """Ï¥ùÏ†ê Í≥ÑÏÇ∞"""
        return (
            self.score['feat_bug_pr'] * p_fb_at +
            self.score['doc_pr'] * p_d_at +
            self.score['typo_pr'] * p_t +
            self.score['feat_bug_is'] * i_fb_at +
            self.score['doc_is'] * i_d_at
        )

    def _create_score_dict(self, p_fb_at: int, p_d_at: int, p_t: int, i_fb_at: int, i_d_at: int, total: int) -> Dict[str, float]:
        """Ï†êÏàò ÎîïÏÖîÎÑàÎ¶¨ ÏÉùÏÑ±"""
        return {
            "feat/bug PR": self.score['feat_bug_pr'] * p_fb_at,
            "document PR": self.score['doc_pr'] * p_d_at,
            "typo PR": self.score['typo_pr'] * p_t,
            "feat/bug issue": self.score['feat_bug_is'] * i_fb_at,
            "document issue": self.score['doc_is'] * i_d_at,
            "total": total
        }

    def _finalize_scores(self, scores: Dict, total_score_sum: float, user_info: Optional[Dict] = None) -> Dict[str, Dict[str, float]]:
        """ÏµúÏ¢Ö Ï†êÏàò Í≥ÑÏÇ∞ Î∞è Ï†ïÎ†¨"""
        # ÎπÑÏú® Í≥ÑÏÇ∞
        for participant in scores:
            total = scores[participant]["total"]
            rate = (total / total_score_sum) * 100 if total_score_sum > 0 else 0
            scores[participant]["rate"] = round(rate, 1)

        # ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Îß§Ìïë (Ï†úÍ≥µÎêú Í≤ΩÏö∞)
        if user_info:
            scores = {user_info[k]: scores.pop(k) for k in list(scores.keys()) if user_info.get(k) and scores.get(k)}

        return dict(sorted(scores.items(), key=lambda x: x[1]["total"], reverse=True))

    def calculate_scores(self, user_info: Optional[Dict[str, str]] = None) -> Dict[str, Dict[str, float]]:
        """Ï∞∏Ïó¨ÏûêÎ≥Ñ Ï†êÏàò Í≥ÑÏÇ∞"""
        scores = {}
        total_score_sum = 0

        for participant, activities in self.participants.items():
            # PR Ïπ¥Ïö¥Ìä∏ Ï∂îÏ∂ú
            p_f, p_b, p_d, p_t, p_fb = self._extract_pr_counts(activities)
            
            # Ïù¥Ïäà Ïπ¥Ïö¥Ìä∏ Ï∂îÏ∂ú
            i_f, i_b, i_d, i_fb = self._extract_issue_counts(activities)
            
            # Ïú†Ìö® Ïπ¥Ïö¥Ìä∏ Í≥ÑÏÇ∞
            p_valid, i_valid = self._calculate_valid_counts(p_fb, p_d, i_fb, i_d)
            
            # Ï°∞Ï†ïÎêú Ïπ¥Ïö¥Ìä∏ Í≥ÑÏÇ∞
            p_fb_at, p_d_at, i_fb_at, i_d_at = self._calculate_adjusted_counts(
                p_fb, p_valid, i_fb, i_valid
            )
            
            # Ï¥ùÏ†ê Í≥ÑÏÇ∞
            total = self._calculate_total_score(p_fb_at, p_d_at, p_t, i_fb_at, i_d_at)
            
            scores[participant] = self._create_score_dict(p_fb_at, p_d_at, p_t, i_fb_at, i_d_at, total)
            total_score_sum += total

        return self._finalize_scores(scores, total_score_sum, user_info)

    def calculate_averages(self, scores: Dict[str, Dict[str, float]]) -> Dict[str, float]:
        """Ï†êÏàò ÎîïÏÖîÎÑàÎ¶¨ÏóêÏÑú Í∞Å Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÌèâÍ∑†ÏùÑ Í≥ÑÏÇ∞Ìï©ÎãàÎã§."""
        if not scores:
            return {"feat/bug PR": 0, "document PR": 0, "feat/bug issue": 0, "document issue": 0, "total": 0, "rate": 0}

        num_participants = len(scores)
        totals = {
            "feat/bug PR": 0,
            "document PR": 0,
            "typo PR": 0,
            "feat/bug issue": 0,
            "document issue": 0,
            "total": 0
        }

        for participant, score_data in scores.items():
            for category in totals.keys():
                totals[category] += score_data[category]

        averages = {category: total / num_participants for category, total in totals.items()}
        total_rates = sum(score_data["rate"] for score_data in scores.values())
        averages["rate"] = total_rates / num_participants if num_participants > 0 else 0

        return averages

    def generate_table(self, scores: Dict[str, Dict[str, float]], save_path) -> None:
        """
        Ï∞∏Í∞ÄÏûêÎì§Ïùò Ï†êÏàò Îç∞Ïù¥ÌÑ∞Î•º CSV ÌååÏùºÎ°ú Ï†ÄÏû•Ìï©ÎãàÎã§.
        ÎòêÌïú Ï†êÏàòÎ•º ÌôòÏÇ∞Ìïú ÌôúÎèô ÌöüÏàò Ï†ïÎ≥¥ÎèÑ Î≥ÑÎèÑÏùò count.csv ÌååÏùºÎ°ú Ï†ÄÏû•Ìï©ÎãàÎã§.

        Args:
            scores (Dict[str, Dict[str, float]]): Ï∞∏Í∞ÄÏûêÎ≥Ñ Í∏∞Ïó¨ Ìï≠Î™© Ï†êÏàò Ï†ïÎ≥¥ÏûÖÎãàÎã§.
            save_path (str): Í≤∞Í≥º CSV ÌååÏùºÏùÑ Ï†ÄÏû•Ìï† Í≤ΩÎ°úÏûÖÎãàÎã§.

        Ï†ÄÏû•ÎêòÎäî ÌååÏùº:
            - [ÏßÄÏ†ïÌïú Í≤ΩÎ°ú].csv: Í∏∞Ïó¨ Ï†êÏàò Îç∞Ïù¥ÌÑ∞
            - count.csv: PR/Ïù¥Ïäà Ìï≠Î™©Î≥Ñ ÌôúÎèô Í∞úÏàò Îç∞Ïù¥ÌÑ∞
        """
        df = pd.DataFrame.from_dict(scores, orient="index")
        df.reset_index(inplace=True)
        df.rename(columns={"index": "name"}, inplace=True)

        dir_path = os.path.dirname(save_path)
        if dir_path and not os.path.exists(dir_path):
            os.makedirs(dir_path)

        df.to_csv(save_path, index=False)
        logging.info(f"üìä CSV Í≤∞Í≥º Ï†ÄÏû• ÏôÑÎ£å: {save_path}")
        
        count_csv_path = os.path.join(dir_path or '.', "count.csv")
        with open(count_csv_path, 'w') as f:
            f.write("name,feat/bug PR,document PR,typo PR,feat/bug issue,document issue\n")
            for name, score in scores.items():
                pr_fb = int(score["feat/bug PR"] / self.score["feat_bug_pr"])
                pr_doc = int(score["document PR"] / self.score["doc_pr"])
                pr_typo = int(score["typo PR"] / self.score["typo_pr"])
                is_fb = int(score["feat/bug issue"] / self.score["feat_bug_is"])
                is_doc = int(score["document issue"] / self.score["doc_is"])
                f.write(f"{name},{pr_fb},{pr_doc},{pr_typo},{is_fb},{is_doc}\n")
        logging.info(f"üìÑ ÌôúÎèô Í∞úÏàò CSV Ï†ÄÏû• ÏôÑÎ£å: {count_csv_path}")

    def generate_text(self, scores: Dict[str, Dict[str, float]], save_path) -> None:
        """
        Ï∞∏Í∞ÄÏûêÎì§Ïùò Ï†êÏàò Îç∞Ïù¥ÌÑ∞Î•º PrettyTable ÌòïÏãùÏùò ÌÖçÏä§Ìä∏Î°ú Ï†ÄÏû•Ìï©ÎãàÎã§.
        ÌèâÍ∑† Îç∞Ïù¥ÌÑ∞ÎèÑ ÏÉÅÎã®Ïóê Ìï®Íªò Ï∂úÎ†•Îê©ÎãàÎã§.

        Args:
            scores (Dict[str, Dict[str, float]]): Ï∞∏Í∞ÄÏûêÎ≥Ñ Í∏∞Ïó¨ Ìï≠Î™© Ï†êÏàò Ï†ïÎ≥¥ÏûÖÎãàÎã§.
            save_path (str): ÌÖçÏä§Ìä∏ ÌååÏùºÏùÑ Ï†ÄÏû•Ìï† Í≤ΩÎ°úÏûÖÎãàÎã§.

        ÎÇ¥Ïö©:
            - Í∞Å Ï∞∏Í∞ÄÏûêÏùò PR/Ïù¥Ïäà Ï†êÏàò, Ï¥ùÏ†ê, ÌôòÏÇ∞Ïú®(rate)ÏùÑ Ìè¨Ìï®
            - ÏÉÅÎã®Ïóê ÌèâÍ∑†Í∞í Ìñâ Î∞è ÏÉùÏÑ± ÏãúÍ∞ÅÎèÑ ÌëúÏãú
        """
        table = PrettyTable()
        table.field_names = ["name", "feat/bug PR", "document PR", "typo PR","feat/bug issue", "document issue", "total", "rate"]

        # ÌèâÍ∑† Í≥ÑÏÇ∞
        averages = self.calculate_averages(scores)

        # ÌèâÍ∑† Ìñâ Ï∂îÍ∞Ä
        table.add_row([
            "avg",
            round(averages["feat/bug PR"], 1),
            round(averages["document PR"], 1),
            round(averages["typo PR"], 1),
            round(averages["feat/bug issue"], 1),
            round(averages["document issue"], 1),
            round(averages["total"], 1),
            f'{averages["rate"]:.1f}%'
        ])

        for name, score in scores.items():
            table.add_row([
                name,
                score["feat/bug PR"],
                score["document PR"],
                score["typo PR"],
                score['feat/bug issue'],
                score['document issue'],
                score['total'],
                f'{score["rate"]:.1f}%'
            ])

        dir_path = os.path.dirname(save_path)
        if dir_path and not os.path.exists(dir_path):
            os.makedirs(dir_path)

        # ÏÉùÏÑ± ÎÇ†Ïßú Î∞è ÏãúÍ∞Ñ Ï∂îÍ∞Ä (ÌÖçÏä§Ìä∏ ÌååÏùº ÏÉÅÎã®)
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M")
        with open(save_path, 'w') as txt_file:
            txt_file.write(f"Generated on: {current_time}\n\n")
            txt_file.write(str(table))
        logging.info(f"üìù ÌÖçÏä§Ìä∏ Í≤∞Í≥º Ï†ÄÏû• ÏôÑÎ£å: {save_path}")

    def _calculate_activity_ratios(self, participant_scores: Dict) -> tuple[float, float, float]:
        """Ï∞∏Ïó¨ÏûêÏùò FEAT/BUG/DOC ÌôúÎèô ÎπÑÏú®ÏùÑ Í≥ÑÏÇ∞"""
        total = participant_scores["total"]
        if total == 0:
            return 0, 0, 0
            
        feat_bug_score = (
            participant_scores["feat/bug PR"] + 
            participant_scores["feat/bug issue"]
        )
        doc_score = (
            participant_scores["document PR"] + 
            participant_scores["document issue"]
        )
        typo_score = participant_scores["typo PR"]
        
        feat_bug_ratio = (feat_bug_score / total) * 100
        doc_ratio = (doc_score / total) * 100
        typo_ratio = (typo_score / total) * 100
        
        return feat_bug_ratio, doc_ratio, typo_ratio

    def generate_chart(self, scores: Dict[str, Dict[str, float]], save_path: str, show_grade: bool = False) -> None:
        """
        Ï∞∏Í∞ÄÏûêÎì§Ïùò Ï†êÏàò Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Î∞òÏúºÎ°ú ÏàòÌèâ ÎßâÎåÄ Ï∞®Ìä∏Î•º ÏÉùÏÑ±ÌïòÍ≥† PNG ÌååÏùºÎ°ú Ï†ÄÏû•Ìï©ÎãàÎã§.

        Args:
            scores (Dict[str, Dict[str, float]]): Ï∞∏Í∞ÄÏûêÎ≥Ñ Ï†êÏàò Îç∞Ïù¥ÌÑ∞ÏûÖÎãàÎã§.
            save_path (str): ÏÉùÏÑ±Îêú Ï∞®Ìä∏ Ïù¥ÎØ∏ÏßÄÎ•º Ï†ÄÏû•Ìï† Í≤ΩÎ°úÏûÖÎãàÎã§.
            show_grade (bool): TrueÏùº Í≤ΩÏö∞ Ï†êÏàòÏóê Îî∞Î•∏ Îì±Í∏â(A~F)ÏùÑ ÏÉâÏÉÅ Î∞è ÌÖçÏä§Ìä∏Î°ú ÌëúÏãúÌï©ÎãàÎã§. Í∏∞Î≥∏Í∞íÏùÄ FalseÏûÖÎãàÎã§.

        Í∏∞Îä•:
            - ÌïúÍ∏Ä Í∏ÄÍº¥ ÏûêÎèô Ï†ÅÏö© (Linux ÌôòÍ≤Ω ÎåÄÏùë)
            - ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÌÖåÎßàÏóê Îî∞Îùº Ï∞®Ìä∏ Ïä§ÌÉÄÏùº Ï†ÅÏö©
            - Ï†êÏàò Ï†ïÎ†¨ Î∞è ÏàúÏúÑ Í≥ÑÏÇ∞
            - Ï†êÏàòÏóê Îî∞Î•∏ Îì±Í∏â ÏÉâÏÉÅ ÌòπÏùÄ colormap Ï†ÅÏö©
            - Í∞úÎ≥Ñ ÎßâÎåÄ ÏòÜÏóê Ï†êÏàò, Îì±Í∏â, ÎπÑÏú®(Í∏∞Îä•/Î¨∏ÏÑú/Ïò§ÌÉÄ ÌôúÎèô ÎπÑÏú®) ÌëúÏãú
            - Ï∞∏Í∞ÄÏûê ÏàòÏóê Îî∞Îùº ÎÜíÏù¥ ÏûêÎèô Ï°∞Ï†à
            - Ï†ÄÏû• Í≤ΩÎ°úÍ∞Ä ÏóÜÏúºÎ©¥ ÎîîÎ†âÌÑ∞Î¶¨ ÏûêÎèô ÏÉùÏÑ±

        Ï†ÄÏû• Í≤∞Í≥º:
            - ÏßÄÏ†ïÎêú Í≤ΩÎ°úÏóê PNG Ï∞®Ìä∏ ÌååÏùºÏù¥ Ï†ÄÏû•Îê©ÎãàÎã§.
        """

      # Linux ÌôòÍ≤ΩÏóêÏÑú CJK Ìè∞Ìä∏ ÏàòÎèô ÏÑ§Ï†ï
        # OSS ÌïúÍ∏Ä Ìè∞Ìä∏Ïù∏ Î≥∏Í≥†Îîï, ÎÇòÎàîÍ≥†Îîï, Î∞±Î¨µ Ï§ë ÏàúÏÑúÎåÄÎ°ú ÌïòÎÇòÎ•º ÏÑ†ÌÉù
        for pref_name in ['Noto Sans CJK', 'NanumGothic', 'Baekmuk Dotum']:
            found_ttf = next((ttf for ttf in fm.fontManager.ttflist if pref_name in ttf.name), None)

            if found_ttf:
                plt.rcParams['font.family'] = found_ttf.name
                break
        theme = self.theme_manager.themes[self.theme_manager.current_theme]  # ÌÖåÎßà Í∞ÄÏ†∏Ïò§Í∏∞

        plt.rcParams['figure.facecolor'] = theme['chart']['style']['background']
        plt.rcParams['axes.facecolor'] = theme['chart']['style']['background']
        plt.rcParams['axes.edgecolor'] = theme['chart']['style']['text']
        plt.rcParams['axes.labelcolor'] = theme['chart']['style']['text']
        plt.rcParams['xtick.color'] = theme['chart']['style']['text']
        plt.rcParams['ytick.color'] = theme['chart']['style']['text']
        plt.rcParams['grid.color'] = theme['chart']['style']['grid']
        plt.rcParams['text.color'] = theme['chart']['style']['text']

        # Ï†êÏàò Ï†ïÎ†¨
        sorted_scores = sorted(
            [(key, value.get('total', 0)) for (key, value) in scores.items()],
            key=lambda item: item[1],
            reverse=True
        )
        participants, scores_sorted = zip(*sorted_scores) if sorted_scores else ([], [])
        num_participants = len(participants)
        
        # ÌÅ¥ÎûòÏä§ ÏÉÅÏàò ÏÇ¨Ïö©
        height = max(
            self.CHART_CONFIG['min_height'],
            num_participants * self.CHART_CONFIG['height_per_participant']
        )

        # Îì±Ïàò Í≥ÑÏÇ∞ (ÎèôÏ†ê Ï≤òÎ¶¨)
        ranks = []
        current_rank = 1
        prev_score = None
        for i, score in enumerate(scores_sorted):
            if score != prev_score:
                ranks.append(current_rank)
                prev_score = score
            else:
                ranks.append(ranks[-1])
            current_rank += 1

        plt.figure(figsize=(self.CHART_CONFIG['figure_width'], height))
        bars = plt.barh(participants, scores_sorted, height=self.CHART_CONFIG['bar_height'])

        # ÏÉâÏÉÅ Îß§Ìïë (Í∏∞Î≥∏ colormap ÎòêÎäî Îì±Í∏âÎ≥Ñ ÏÉâÏÉÅ)
        if show_grade:
            def get_grade_color(score):
                if score >= 90:
                    return theme['colors']['grade_colors']['A']
                elif score >= 80:
                    return theme['colors']['grade_colors']['B']
                elif score >= 70:
                    return theme['colors']['grade_colors']['C']
                elif score >= 60:
                    return theme['colors']['grade_colors']['D']
                elif score >= 50:
                    return theme['colors']['grade_colors']['E']
                else:
                    return theme['colors']['grade_colors']['F']

            for bar, score in zip(bars, scores_sorted):
                bar.set_color(get_grade_color(score))
        else:
            colormap = plt.colormaps[theme['chart']['style']['colormap']]
            norm = plt.Normalize(min(scores_sorted or [0]), max(scores_sorted or [1]))
            for bar, score in zip(bars, scores_sorted):
                bar.set_color(colormap(norm(score)))

        plt.xlabel('Participation Score')
        timestamp = datetime.now(ZoneInfo("Asia/Seoul")).strftime("Generated at %Y-%m-%d %H:%M:%S")
        plt.title(f'Repository Participation Scores\n{timestamp}')
        plt.suptitle(f"Total Participants: {num_participants}", fontsize=10, x=0.98, ha='right')
        plt.gca().invert_yaxis()

        # Ï†êÏàòÏôÄ ÌôúÎèô ÎπÑÏú® ÌëúÏãú
        for i, (bar, score) in enumerate(zip(bars, scores_sorted)):
            participant = participants[i]
            feat_bug_ratio, doc_ratio, typo_ratio = self._calculate_activity_ratios(scores[participant])
            
            grade = ''
            if show_grade:
                # ÏÉÅÏàò ÏÇ¨Ïö©
                grade_assigned = 'F'
                for threshold, grade_letter in sorted(self.GRADE_THRESHOLDS.items(), reverse=True):
                    if score >= threshold:
                        grade_assigned = grade_letter
                        break
                grade = f" ({grade_assigned})"

            # Ï†êÏàò, Îì±Í∏â, ÏàúÏúÑ ÌëúÏãú
            score_text = f'{int(score)}{grade} ({ranks[i]}ÏúÑ)'
            
            # ÌôúÎèô ÎπÑÏú® ÌëúÏãú (ÏïûÍ∏ÄÏûêÎßå ÏÇ¨Ïö©)
            ratio_text = f'F/B: {feat_bug_ratio:.1f}% D: {doc_ratio:.1f}% T: {typo_ratio:.1f}%'
            
            plt.text(
                bar.get_width() + self.CHART_CONFIG['label_offset'],
                bar.get_y() + bar.get_height() / 2,
                f'{score_text}\n{ratio_text}',
                va='center',
                fontsize=self.CHART_CONFIG['font_size']
            )

        # ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏóÜÏúºÎ©¥ ÏÉùÏÑ±
        save_dir = os.path.dirname(save_path)
        if save_dir and not os.path.exists(save_dir):
            os.makedirs(save_dir, exist_ok=True)

        plt.subplots_adjust(left=0.25, right=0.98, top=0.93, bottom=0.05)
        plt.savefig(save_path)
        logging.info(f"üìà Ï∞®Ìä∏ Ï†ÄÏû• ÏôÑÎ£å: {save_path}")
        plt.close()